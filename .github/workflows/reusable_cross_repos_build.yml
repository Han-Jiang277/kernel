name: Reusable trigger of building cross multiple repositories

on:
  workflow_call:

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      checks: write
      pull-requests: write

    container:
      image: ghcr.io/${{ github.repository_owner }}/kernel:latest

    if: ${{ github.event.issue.pull_request && contains(github.event.comment.body, 'build_prs') }}
    steps:
      - name: Notify job started
        uses: actions/github-script@v8
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `Job is started, see ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}.`
            })

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Prepare directories
        run: |
          # sysroot/ contains toolchain.
          mkdir -p sysroot/usr/local/bin
          echo "$PWD/sysroot/usr/local/bin" >> "$GITHUB_PATH"
          # patches/ contains patches downloaded.
          mkdir -p patches

      - name: Download patches
        id: fetch_prs
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs').promises;
            const body = context.payload.comment.body;
            const prRegex = /https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/g;
            let match;
            let prs = [];
            let patchUrls = [];
            let fetched_prs = [];
            while ((match = prRegex.exec(body)) !== null) {
              let owner = match[1];
              let repo = match[2];
              let pr_num = match[3];
              prs.push({owner: owner, repo: repo, pr_num: pr_num});
              patchUrls.push({repo: repo, url: match[0] + ".diff"});
            }
            // Get metadata of the PR.
            await Promise.all(prs.map(async({ owner, repo, pr_num }) => {
              const { data: pullRequest } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr_num,
              });
              fetched_prs.push({owner: owner, repo: repo, pr_num: pr_num, sha: pullRequest.head.sha});
            }));

            // Download diffs.
            await Promise.all(patchUrls.map(async ({ repo, url }) => {
              console.log(`Downloading ${url}`);
              const patchFilename = `patches/${repo}.diff`;
              const response = await github.request({
                url: url,
              });
              await fs.writeFile(patchFilename, response.data);
            }));
            core.setOutput('fetched_prs', JSON.stringify(fetched_prs));

      - name: Init repo and sync
        run: |
          repo init --depth=1 -u https://github.com/vivoblueos/manifests.git -b main -m manifest.xml
          repo sync -j$(nproc)

      - name: Apply patches
        run: |
          set -e
          set -x
          for patch in patches/*.diff; do
            patch_abspath=$(realpath ${patch})
            repo=$(basename ${patch} ".diff")
            if [[ ${repo} != "manifests" ]];then
              pushd ${repo}
            else
              pushd .repo/${repo}
            fi
            git apply -3 --check --verbose ${patch_abspath} && git apply -3 --verbose ${patch_abspath}
            if [[ $? != 0 ]]; then
              exit 1
            fi
            popd
          done

      - name: Re-sync repos
        # In case manifests repo is changed.
        run: |
          repo sync -j$(nproc)

      # FIXME: We should use action's builtin matrix.
      - name: Build and test the kernel
        run: |
          ./build/ci/run_ci.py

      - name: Notify job ended
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const sign = "${{ job.status }}" === 'success' ? '✅' : '❌';
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `Job ends with ${sign} ${{ job.status }}, see ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}.`
            })
